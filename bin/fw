#!/usr/bin/env python3

import argparse
import datetime
import os
import subprocess
import time

BLUE, RED, RESET = "\033[34m", "\033[31m", "\033[0m"


def main():
    parser = argparse.ArgumentParser(description="run commands when files change")
    parser.add_argument("command")
    parser.add_argument("-p", "--paths", nargs="+", default=["."])
    parser.add_argument("-c", "--clear", action="store_true")
    parser.add_argument("-d", "--delay", type=float, default=0.4)
    args = parser.parse_args()

    os.system("clear")
    current_process = None
    try:
        last_modified = {path: os.path.getmtime(path) for path in args.paths}

        current_process = run_command(args.command)

        while True:
            file_changed = False
            for path in args.paths:
                current_modified = os.path.getmtime(path)
                if current_modified != last_modified[path]:
                    file_changed = True
                    break

            if file_changed:
                if current_process and current_process.poll() is None:
                    print(f"{RED}change detected, terminating process{RESET}\n")
                    current_process.terminate()
                    try:
                        # wait for the process to terminate
                        current_process.wait(timeout=5)
                    except subprocess.TimeoutExpired:
                        print(f"{RED}forcefully exiting process{RESET}")
                        current_process.kill()

                if args.clear:
                    os.system("clear")

                current_process = run_command(args.command)

                last_modified = {path: os.path.getmtime(path) for path in args.paths}

            time.sleep(args.delay)
    except KeyboardInterrupt:
        # handle ctrl+c gracefully
        if current_process and current_process.poll() is None:
            current_process.terminate()
            try:
                current_process.wait(timeout=5)
            except subprocess.TimeoutExpired:
                print(f"{RED}forcefully exiting process{RESET}")
                current_process.kill()
        pass


def run_command(command):
    print(f"\n{BLUE}{datetime.datetime.now()}{RESET} {command}")
    try:
        process = subprocess.Popen(command, shell=True, preexec_fn=os.setsid)
        return process
    except Exception as e:
        print(f"{RED}err: executing command: {e}{RESET}")
        return None


if __name__ == "__main__":
    main()
